{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///preload.min.js","webpack:///webpack/bootstrap edb26a7e4e9cc6206bfc","webpack:///./src/index.js"],"names":["root","factory","exports","module","define","amd","preload","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","default","object","property","prototype","hasOwnProperty","p","s","image","_len","arguments","length","images","Array","_key","Promise","reject","Error","EMPTY_PARAMS_MESSAGE","reflected","map","oneImage","catch","error","all","then","resolved","filter","STATE_FAILED","_typeof","HTMLImageElement","TypeError","TYPE_ERROR_MESSAGE","reason","url","Image","src","resolve","fullfill","state","STATE_NEW","naturalWidth","STATE_LOADED","removeEventListener","complete","addEventListener","Symbol","iterator","obj","constructor"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAA,aAAAH,GACA,gBAAAC,SACAA,QAAAI,QAAAL,IAEAD,EAAAM,QAAAL,KACCM,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAR,OAGA,IAAAC,GAAAQ,EAAAD,IACAE,EAAAF,EACAG,KACAX,WAUA,OANAM,GAAAE,GAAAI,KAAAX,EAAAD,QAAAC,IAAAD,QAAAO,GAGAN,EAAAU,KAGAV,EAAAD,QAvBA,GAAAS,KA+DA,OAnCAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAG,EAAA,SAAAK,GAA2C,MAAAA,IAG3CR,EAAAS,EAAA,SAAAhB,EAAAiB,EAAAC,GACAX,EAAAY,EAAAnB,EAAAiB,IACAG,OAAAC,eAAArB,EAAAiB,GACAK,gBACAC,cACAC,IAAAN,KAMAX,EAAAkB,EAAA,SAAAxB,GACA,GAAAiB,GAAAjB,KAAAyB,WACA,WAA2B,MAAAzB,GAAA0B,SAC3B,WAAiC,MAAA1B,GAEjC,OADAM,GAAAS,EAAAE,EAAA,IAAAA,GACAA,GAIAX,EAAAY,EAAA,SAAAS,EAAAC,GAAsD,MAAAT,QAAAU,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDtB,EAAAyB,EAAA,GAGAzB,IAAA0B,EAAA,KDgBM,SAAShC,EAAQD,EAASO,GAEhC,YEhDe,SAASH,KAAmB,OACrC8B,UADqCC,EAAAC,UAAAC,OAARC,EAAQC,MAAAJ,GAAAK,EAAA,EAAAA,EAAAL,EAAAK,IAARF,EAAQE,GAAAJ,UAAAI,EAIzC,IAAsB,IAAlBF,EAAOD,OACT,MAAOI,SAAQC,OAAO,GAAIC,OAAMC,GAC3B,IAAsB,IAAlBN,EAAOD,OAEX,CAEL,GAAMQ,MAAeC,IAAIlC,KAAK0B,EAAQ,SAAAS,GAAA,MAAY3C,GAAQ2C,GAAUC,MAAM,SAAAC,GAAA,MAASA,MAEnF,OAAOR,SAAQS,IAAIL,GAAWM,KAAK,SAAAC,GAAA,MAAYA,GAASC,OAAO,SAAAN,GAAA,MAAYA,GAAS,KAAOO,MAK7F,GAVEpB,EAAQI,EAAO,GAUI,YAAjB,mBAAOJ,GAAP,YAAAqB,EAAOrB,OAAwBA,YAAiBsB,mBAClD,MAAOf,SAAQC,OAAO,GAAIe,WAAUC,IAAqBP,KAAK,SAAAQ,GAAA,MAAUA,IAI1E,IAAqB,gBAAVzB,IAAgC,KAAVA,EAC/B,MAAOO,SAAQC,OAAO,GAAIC,OAAMC,IAAuBO,KAAK,SAAAQ,GAAA,MAAUA,IAIxE,IAAqB,gBAAVzB,GAAoB,CAC7B,GAAI0B,GAAM1B,CAGVA,GAAQ,GAAI2B,OACZ3B,EAAM4B,IAAMF,EAGd,MAAO,IAAInB,SAAQ,SAACsB,EAASrB,GAC3B,GAAMsB,GAAW,QAAXA,KACJ,GAAIC,GAAQC,CAERhC,GAAMiC,cACRF,EAAQG,EAERlC,EAAMmC,oBAAoB,OAAQL,GAClC9B,EAAMmC,oBAAoB,QAASL,GACnCD,GAAS7B,EAAO+B,KACP/B,EAAMoC,WAEbL,EADuB,mBAAd/B,GAAM4B,KAAqC,KAAd5B,EAAM4B,IACpCI,EAEAZ,EAGVpB,EAAMmC,oBAAoB,OAAQL,GAClC9B,EAAMmC,oBAAoB,QAASL,GACnCtB,GAAQR,EAAO+B,KAIf/B,aAAiBsB,oBACnBtB,EAAMqC,iBAAiB,OAAQP,GAC/B9B,EAAMqC,iBAAiB,QAASP,MFTtC5C,OAAOC,eAAerB,EAAS,cAC7Be,UAGF,IAAIwC,GAA4B,kBAAXiB,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,QAAUE,IAAQF,OAAO1C,UAAY,eAAkB4C,GAEtQ1E,GAAQ2B,QEzDgBvB,CAjCjB,IAAM8D,eAAY,MACZE,iBAAe,SACfd,iBAAe,SAGfV,yBAAuB,6FAEvBc,uBAAqB","file":"preload.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"preload\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"preload\"] = factory();\n\telse\n\t\troot[\"preload\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"preload\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"preload\"] = factory();\n\telse\n\t\troot[\"preload\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = preload;\n// Possible state for HTMLImageElement\nvar STATE_NEW = exports.STATE_NEW = 'new'; // for all new Image() without src\nvar STATE_LOADED = exports.STATE_LOADED = 'loaded'; // for resolved and loaded images\nvar STATE_FAILED = exports.STATE_FAILED = 'failed'; // for rejected images\n\n// Errors messages for pretty errors in runtime\nvar EMPTY_PARAMS_MESSAGE = exports.EMPTY_PARAMS_MESSAGE = 'Empty params: ' + 'you can pass an image/images and it must be URL (string) or HTMLImageElement';\nvar TYPE_ERROR_MESSAGE = exports.TYPE_ERROR_MESSAGE = 'Incorrect params: ' + 'image must be URL string or HTMLImageElement';\n\n/**\n * Preload images.\n * Return Promise on loading images from URL string or HTMLImageElement object.\n *\n * @param {string|HTMLImageElement} images Set of URL's or HTMLImageElement's.\n *\n * @returns {Promise}\n *\n * @function\n * @example\n * import preload from '@bautrukevich/preload';\n *\n * let orImageWithSrc = new Image();\n * orImageWithSrc.src = '/url/path/to/image';\n * let orImageWithoutSrc = new Image(); // it's valid and you can set src later\n *\n * const result = preload('/url/path/to/image', orImageWithSrc, orImageWithoutSrc)\n *  .then(resolved => {\n *    console.log(resolved);\n *  }, rejected => {\n *    console.log(rejected);\n *  });\n */\nfunction preload() {\n  var image = void 0;\n\n  // Check arguments count\n\n  for (var _len = arguments.length, images = Array(_len), _key = 0; _key < _len; _key++) {\n    images[_key] = arguments[_key];\n  }\n\n  if (images.length === 0) {\n    return Promise.reject(new Error(EMPTY_PARAMS_MESSAGE));\n  } else if (images.length === 1) {\n    image = images[0];\n  } else {\n    // Make recursive call of preload for each image (string URL or HTMLImageElement)\n    var reflected = [].map.call(images, function (oneImage) {\n      return preload(oneImage).catch(function (error) {\n        return error;\n      });\n    });\n\n    return Promise.all(reflected).then(function (resolved) {\n      return resolved.filter(function (oneImage) {\n        return oneImage[1] !== STATE_FAILED;\n      });\n    });\n  }\n\n  // Check for type errors\n  // Accept only HTMLImageElement interface\n  if ((typeof image === 'undefined' ? 'undefined' : _typeof(image)) === 'object' && !(image instanceof HTMLImageElement)) {\n    return Promise.reject(new TypeError(TYPE_ERROR_MESSAGE)).then(function (reason) {\n      return reason;\n    });\n  }\n\n  // And not empty string\n  if (typeof image === 'string' && image === '') {\n    return Promise.reject(new Error(EMPTY_PARAMS_MESSAGE)).then(function (reason) {\n      return reason;\n    });\n  }\n\n  // and not empty string as URL\n  if (typeof image === 'string') {\n    var url = image;\n\n    // Create a new img from HTML5 constructor and set src\n    image = new Image();\n    image.src = url;\n  }\n\n  return new Promise(function (resolve, reject) {\n    var fullfill = function fullfill() {\n      var state = STATE_NEW;\n\n      if (image.naturalWidth) {\n        state = STATE_LOADED;\n\n        image.removeEventListener('load', fullfill);\n        image.removeEventListener('error', fullfill);\n        resolve([image, state]);\n      } else if (image.complete) {\n        if (typeof image.src === 'undefined' || image.src === '') {\n          state = STATE_NEW;\n        } else {\n          state = STATE_FAILED;\n        }\n\n        image.removeEventListener('load', fullfill);\n        image.removeEventListener('error', fullfill);\n        reject([image, state]);\n      }\n    };\n\n    if (image instanceof HTMLImageElement) {\n      image.addEventListener('load', fullfill);\n      image.addEventListener('error', fullfill);\n    }\n  });\n}\n\n/***/ }\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// preload.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap edb26a7e4e9cc6206bfc","// Possible state for HTMLImageElement\nexport const STATE_NEW = 'new'; // for all new Image() without src\nexport const STATE_LOADED = 'loaded'; // for resolved and loaded images\nexport const STATE_FAILED = 'failed'; // for rejected images\n\n// Errors messages for pretty errors in runtime\nexport const EMPTY_PARAMS_MESSAGE = 'Empty params: ' +\n  'you can pass an image/images and it must be URL (string) or HTMLImageElement';\nexport const TYPE_ERROR_MESSAGE = 'Incorrect params: ' +\n  'image must be URL string or HTMLImageElement';\n\n/**\n * Preload images.\n * Return Promise on loading images from URL string or HTMLImageElement object.\n *\n * @param {string|HTMLImageElement} images Set of URL's or HTMLImageElement's.\n *\n * @returns {Promise}\n *\n * @function\n * @example\n * import preload from '@bautrukevich/preload';\n *\n * let orImageWithSrc = new Image();\n * orImageWithSrc.src = '/url/path/to/image';\n * let orImageWithoutSrc = new Image(); // it's valid and you can set src later\n *\n * const result = preload('/url/path/to/image', orImageWithSrc, orImageWithoutSrc)\n *  .then(resolved => {\n *    console.log(resolved);\n *  }, rejected => {\n *    console.log(rejected);\n *  });\n */\nexport default function preload(...images) {\n  let image;\n\n  // Check arguments count\n  if (images.length === 0) {\n    return Promise.reject(new Error(EMPTY_PARAMS_MESSAGE));\n  } else if (images.length === 1) {\n    image = images[0];\n  } else {\n    // Make recursive call of preload for each image (string URL or HTMLImageElement)\n    const reflected = [].map.call(images, oneImage => preload(oneImage).catch(error => error));\n\n    return Promise.all(reflected).then(resolved => resolved.filter(oneImage => oneImage[1] !== STATE_FAILED));\n  }\n\n  // Check for type errors\n  // Accept only HTMLImageElement interface\n  if (typeof image === 'object' && !(image instanceof HTMLImageElement)) {\n    return Promise.reject(new TypeError(TYPE_ERROR_MESSAGE)).then(reason => reason);\n  }\n\n  // And not empty string\n  if (typeof image === 'string' && image === '') {\n    return Promise.reject(new Error(EMPTY_PARAMS_MESSAGE)).then(reason => reason);\n  }\n\n  // and not empty string as URL\n  if (typeof image === 'string') {\n    let url = image;\n\n    // Create a new img from HTML5 constructor and set src\n    image = new Image();\n    image.src = url;\n  }\n\n  return new Promise((resolve, reject) => {\n    const fullfill = () => {\n      let state = STATE_NEW;\n\n      if (image.naturalWidth) {\n        state = STATE_LOADED;\n\n        image.removeEventListener('load', fullfill);\n        image.removeEventListener('error', fullfill);\n        resolve([image, state]);\n      } else if (image.complete) {\n        if (typeof image.src === 'undefined' || image.src === '') {\n          state = STATE_NEW;\n        } else {\n          state = STATE_FAILED;\n        }\n\n        image.removeEventListener('load', fullfill);\n        image.removeEventListener('error', fullfill);\n        reject([image, state]);\n      }\n    };\n\n    if (image instanceof HTMLImageElement) {\n      image.addEventListener('load', fullfill);\n      image.addEventListener('error', fullfill);\n    }\n  });\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js"],"sourceRoot":""}